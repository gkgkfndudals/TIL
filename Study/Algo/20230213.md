# 알고리즘 #6 Linked List

강의 번호: 알고리즘
복습: No
작성일시: 2023년 2월 13일 오전 10:20

## 1. 리스트(List)

- 순서를 가진 데이터의 집합을 가리키는 추상자료형(abstract data type)
- 리스트의 원하는 위치에 추가를 했다면, 정확하게 해당 위치에서 원소가 조회되어야 함.
    - Set : 순서 X, add(E e) - index 이용하는 추가기능 제공하지 않는다.
    - TreeSet : 원소 정렬된 집합
- 동일한 데이터를 가지고 있어도 상관없다.
- 구현 방법에 따라 크게 두 가지로 나뉜다.
    
    (1) **순차 리스트** : 배열을 기반으로 구현된 리스트
    
    (2) **연결 리스트**: 메모리의 동적할당을 기반으로 구현된 리스트
    

### 순차 리스트

- **구현 방법**
    
    (1) 1차원 배열에 항목들을 순서대로 저장한다
    
    → 크기 지정한 채로 배열 생성
    
    (2) 데이터의 종류와 구조에 따라 구조화된 자료구조를 만들어 배열에 저장할 수도 있다.
    

![](https://github.com/gkgkfndudals/TIL/blob/master/Study/img/20230213_1.png)

- **데이터 접근**
    
    배열의 인덱스를 이용해 원하는 위치의 데이터에 접근할 수 있다.
    
    ![](https://github.com/gkgkfndudals/TIL/blob/master/Study/img/20230213_2.png)
    
- **삽입 연산**
    
    삽입 위치 다음의 항목들을 뒤로 이동해야 한다
    
    ![](https://github.com/gkgkfndudals/TIL/blob/master/Study/img/20230213_3.png)
    
- **삭제 연산**
    
    삭제 위치 다음의 항목들을 앞으로 이동해야 한다.
    
    ![](https://github.com/gkgkfndudals/TIL/blob/master/Study/img/20230213_4.png)
    
- **문제점**
    - 단순 배열을 이용한 순차리스트를 구현해 사용하는 경우, 자료의 삽입/삭제 연산 과정에서 연속적인 메모리 배열을 위해 원소들을 이동시키는 작업이 필요하다.
    - 원소의 개수가 많고, 삽입/삭제 연산이 빈번하게 일어날수록 작업에 소요되는 시간이 크게 증가한다.
    - 배열의 크기가 정해져 있는 경우, 실제로 사용될 메모리보다 크게 할당되어 **메모리의 낭비**를 초래할 수 있고, 반대로 할당된 메모리보다 많은 자료를 사용하여 새롭게 배열을 만들어 작업을 해야하는 경우가 발생할 수도 있다.
    

### 연결 리스트(Linked List)

- **특성**
    - **자료의 논리적인 순서와 메모리 상의 물리적인 순서가 일치하지 않고**, 개별적으로 위치하고 있는 각 원소를 연결하여 하나의 전체적인 자료구조를 이룬다
    - 링크를 통해 원소에 접근하므로, 순차 리스트처럼 물리적인 순서를 맞추기 위한 작업이 필요하지 않다.
    - 자료구조의 크기를 동적으로 조절할 수 있어, **메모리의 효율적인 사용**이 가능하다.
    
- **노드**
    
    연결 리스트에서 하나의 **원소**를 표현하는 building block
    
    **구성 요소**
    
    (1) 데이터 필드
    
    — 원소의 값을 저장 - 단일값, 여러 값으로 구성도 가능
    
    — 저장할 원소의 종류나 크기에 따라 구조를 정의하여 사용 - 사용자 정의 class
    
    ![](https://github.com/gkgkfndudals/TIL/blob/master/Study/img/20230213_5.png)
    
    <aside>
    💡 Singleton 디자인 패턴에서도 link(next) 처럼 자기 자신과 같은 타입을 참조하는 변수가 있다!
    
    </aside>
    
    (2) 링크 필드
    
    다음 노드의 참조값을 저장
    
- **헤드** : 연결 리스트의 첫 노드에 대한 참조값을 갖고 있음.

![](https://github.com/gkgkfndudals/TIL/blob/master/Study/img/20230213_6.png)

(1) 더미 노드를 생성하여 연결 : head는 항상 Null이 아니다.

(2) 첫 노드를 저장 : head가 Null일 수도 있음

- 종류
    - 단순 연결 리스트
    - 이중 연결 리스트
    - 원형 연결 리스트 - 단순 연결 리스트, 이중 연결 리스트
    

![](https://github.com/gkgkfndudals/TIL/blob/master/Study/img/20230213_7.png)

## 2. 단순 연결 리스트

- 연결 구조
    
    노드가 하나의 링크 필드에 의해 다음 노드와 연결되는 구조를 가진다.
    
    링크 필드가 Null인 노드가 연결 리스트의 가장 마지막 노드이다.
    

### 삽입 연산

- **공백 리스트의 첫번째에 ‘A’ 노드를 삽입할 때**
    
    (1) 새로운 노드 new 생성
    
    (2) 새로운 노드 new의 데이터 필드에 ‘A’ 저장
    
    (3) head에 저장된 참조값을 새로운 노드 new의 링크 필드값에 저장
    
    (4) head에 새로운 노드 new의 찹조값을 저장
    

- **‘A’를 원소로 갖고 있는 리스트의 첫번째에 ‘C’ 노드를 삽입할 때**
    
    (1) 새로운 노드 new 생성
    
    (2) 새로운 노드 new의 데이터 필드에 ’C’ 저장
    
    (3) head에 저장된 참조값을 새로운 노드 new의 링크 필드값에 저장
    
    (4) head에 새로운 노드 new의 참조값을 저장
    
    ![](https://github.com/gkgkfndudals/TIL/blob/master/Study/img/20230213_8.png)
    
- **‘C’, ‘A’를 원소로 갖고 있는 리스트의 마지막에 ‘D’ 노드를 삽입할 때**
    
    (1) 새로운 노드 new 생성
    
    (2) 새로운 노드 new 생성의 데이터 필드에 ‘D’, 링크 필드에는 Null 저장
    
    (3) 리스트의 마지막 노드의 링크 필드에 새로운 노드 new의 참조값을 저장
    
    ![](https://github.com/gkgkfndudals/TIL/blob/master/Study/img/20230213_9.png)
    
- **‘C’, ‘A’, ‘D’를 원소로 갖고 있는 리스트의 두번째에 ‘B’ 노드를 삽입할 때**
    
    (1) 새로운 노드 new 생성
    
    (2) 새로운 노드 new 생성의 데이터 필드에 ‘B’ 저장
    
    (3) 삽입될 위치의 바로 앞에 위치한 노드의 링크 필드를 new의 링크 필드에 복사
    
    (4) 새로운 노드 new 생성의 참조값을 바로 앞 노드의 링크 필드에 저장
    
    ![](https://github.com/gkgkfndudals/TIL/blob/master/Study/img/20230213_10.png)
    

### 삭제 연산

- ‘A’, ‘B’, ‘C’, ‘D’를 원소로 갖고 있는 리스트의 ‘B’ 노드를 삭제할 때
    
    (1) 삭제할 노드의 앞 노드(선행노드) 탐색
    
    (2) 삭제할 노드의 링크 필드를 선행노드의 링크 필드에 복사
    
    (3) 삭제할 노드의 링크 필드에 Null 저장
    
- ‘A’, ‘C’, ‘D’를 원소로 갖고 있는 리스트의 ‘A’ 노드를 삭제할 때
    
    (1) 삭제할 노드의 앞 노드(선행노드) 탐색
    
    (2) 삭제할 노드의 링크 필드를 리스트의 head에 복사
    
    (3) 삭제할 노드의 링크 필드에 Null 저장
    
    ![](https://github.com/gkgkfndudals/TIL/blob/master/Study/img/20230213_11.png)
    

### 단순 연결 리스트 응용 - 스택 구현

- 단순 연결리스트로 스택 자료구조 구현!
- push와 pop에 적합한 삽입/삭제 알고리즘은??
    
    ⇒ head: top
    
    삽입 : 맨 앞(top)에 삽입
    
    삭제 : 맨 앞에 삭제