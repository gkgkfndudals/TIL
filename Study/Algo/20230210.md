# 알고리즘 #5 Stack/Queue

복습: No
작성일시: 2023년 2월 10일 오전 9:00

## 1. 부분집합 응용 - 바이너리 카운팅

비트 1개: flag로 활용

30개의 상태를 관리

— 선택, 방문(처리)

— 비선택, 비방문(미처리)

→ boolean[30]

→ 1byte * 30 (정수 32bit)

<< : 내가 원하는(비교하기 원하는, 찾기 원하는) 자리 확인할 비트열 생성

_ & _ : 내가 보고싶은 자리의 비트들이 1인지 확인(조건체크 역할)

_ | _ : 내가 처리하고 싶은 자리의 비트를 1로 만듦

### 바이너리 카운팅

- 원소 수에 해당하는 N개의 비트열을 이용한다
- n번째 비트값이 1이면 n번째 원소가 포함되었음을 의미한다

![](https://github.com/gkgkfndudals/TIL/blob/master/Study/img/20230210_1.png)

## 2. 스택(Stack)

- 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조
- 스택에 저장된 자료는 선형 구조를 갖는다.
    - **선형 구조**: 자료 간의 관계가 1:1의 관계를 갖는다.
    - **비선형 구조**: 자료간의 관계가 1:N의 관계를 갖는다.
- 후입선출구조(LIFO)
    - 마지막에 삽입한 자료를 가장 먼저 꺼낸다
    

![](https://github.com/gkgkfndudals/TIL/blob/master/Study/img/20230210_2.png)

peek: 삭제되지 않는다

![](https://github.com/gkgkfndudals/TIL/blob/master/Study/img/20230210_3.png)

### 스택 활용 - 계산기

1. 중위 표기법의 수식을 후위 표기법으로 변경한다. (스택 이용)
    
    1) 수식의 각 연산자에 대해서 우선순위에 따라 괄호를 사용하여 다시 표현
    
    2) 각 연산자를 그에 대응하는 오른쪽 괄호의 뒤로 이동시킨다
    
    3) 괄호를 제거한다.
    
2. 후위 표기법의 수식을 스택을 이용하여 계산한다.
    
    1) 피연산자를 만나면 스택에 push한다
    
    2) 연산자를 만나면 필요한 만큼의 피연산자를 스택에서 pop하여 연산하고, 연산결과를 다시 스택에 push한다
    
    3) 수식이 끝나면 마지막으로 스택을 pop하여 출력한다.
    

## 3. 큐(Queue)

- 선입선출구조(FIFO)

![](https://github.com/gkgkfndudals/TIL/blob/master/Study/img/20230210_4.png)

![](https://github.com/gkgkfndudals/TIL/blob/master/Study/img/20230210_5.png)

peek()도 있음!

Queue보다 ArrayDeque을 더 많이 쓴다. 데이터양이 많을때 속도가 30%정도  빠르다.

### 큐 - 버퍼

- 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역
- 버퍼는 일반적으로 입출력 및 네트워크와 관련된 기능에서 이용된다.
- 순서대로 입력/출력/전달되어야 하므로 FIFO 방식의 자료구조인 큐가 활용된다.